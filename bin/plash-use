#!/usr/bin/env python3
#
# usage: plash-use PROGRAM [CMD1 [CMD2 ...]]
# Quickly use any program.

from plashlib.utils import catch_and_die, die, die_with_usage, handle_help_flag, plash_map
from plashlib import ux
from subprocess import CalledProcessError, DEVNULL, check_call, check_output
import signal
import sys
import os
import tempfile

handle_help_flag()
ux.assert_initialized()

#
# find out the program to run
# if we are symliked take the name of the link file
#
basename = os.path.basename(sys.argv[0])
if basename == 'plash-use':
    try:
        prog = sys.argv[1]
    except IndexError:
        die_with_usage()
    prog_args = sys.argv[2:]
else:
    prog = basename
    prog_args = sys.argv[1:]

cache_key = 'plash-use-{}'.format(prog)
run_container = plash_map(cache_key)
if run_container:
    # short reace condition, it could get deleted in between
    os.execlp('plash-run', 'plash-run', run_container, prog, *prog_args)

log = open(tempfile.mktemp(), 'w')

# print('da log file:', log)
child = os.fork()
if not child:
    print('plash-use: caching... (hit Ctrl-d for logs)', file=sys.stderr)
    while True:
        try:
            input('')
        except KeyboardInterrupt:
            sys.exit(0)
        except EOFError:
            os.execlp('tail', 'tail', '-f', log.name)

#
# find out the package name for this binary
#
query_container = check_output(
    [
        'plash-build',
        '--arch',
        '--namespace',
        'plash-use',
        '--devinit',
        '--layer',
        '--pacman',
        'pkgfile',
        '--run',
        'pkgfile --update',
    ],
    stderr=log)  # --rebuild-every xdays with a system upgrade!!
query_container = query_container.decode().strip('\n')
try:
    install_package = check_output(
        ['plash-run', query_container, 'pkgfile', '-bs', prog],
        stderr=log).decode().splitlines()[0]
except CalledProcessError:
    die('programm {} not found'.format(prog))

#
# "install" the package
#
final_container = check_output(
    [
        'plash-build', '--arch', '--namespace', 'plash-use', '--devinit',
        '--layer', '--pacman', install_package
    ],
    stderr=log)
final_container = final_container.decode().strip('\n')

#
# create a alias for every binary in that package
#
out = check_output(
    ['plash-run', query_container, 'pkgfile', '-bl', install_package],
    stderr=log)
call_names = [
    os.path.basename(entry.split('\t')[-1])
    for entry in out.decode().splitlines()
]
# print('{} provides {}'.format(install_package, ' '.join(call_names)))
for call_name in call_names:
    plash_map('plash-use-{}'.format(call_name), final_container)

#
# finally run the program again
#
os.kill(child, signal.SIGINT)
os.execlp('plash-run', 'plash-run', final_container, prog, *prog_args)
